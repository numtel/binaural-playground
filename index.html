<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Binaural Playground</title>
<style>
button {padding: 10px; font-size:120%;}
textarea {display:block; width: 100%; height: 60vh;}
summary {cursor:pointer;}
</style>
</head>
<body>
<h1>Binaural Playground</h1>
<button onclick="play(event)">Play</button>
<textarea>
0,446,432
3000,446,432
3001,432,446
6000,432,446
6001,446,432
</textarea>
<details>
<summary>Help</summary>
<ul>
<li>Type sequence of steps in the box.
  <p>Each line contains 3 whole numbers separated by commas:
  <ul>
    <li>timestamp (in milliseconds)
    <li>left channel frequency (hertz)
    <li>right channel frequency (hertz)
  </ul>
<li>Frequencies shift linearly between steps
<li>Sequence will repeat until clicking stop
<li>Share sequences by copying the URL
<li>When 'Play' is clicked, the page URL is updated with the encoded sequence appended. Bookmark or share these URLs to save the sounds.
<li>Wear headphones and make sure that they're on with correct left/right
<li>Binaural guide
  <p>The difference between left and right channel frequency is the binaural frequency experienced, e.g. 100 Hz left, 103 Hz right = 3 Hz binaural
  <ul>
    <li>1-4 Hz: Delta (Deep sleep)
    <li>4-8 Hz: Theta (Meditation/REM)
    <li>8-14 Hz: Alpha (Relaxation)
    <li>14-30 Hz: Beta (Focus/Energy)
    <li>30-100 Hz: Gamma (Maximum Awareness)
  </ul>
  <p>Experiment with which side has the higher frequency
</ul>
</details>
<script>
function play(event) {
  const raw = document.querySelector('textarea').value.split('\n');

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const gainNode = audioCtx.createGain();
  gainNode.connect(audioCtx.destination);

  const leftNode = audioCtx.createStereoPanner();
  leftNode.pan.setValueAtTime(-1, audioCtx.currentTime);
  leftNode.connect(gainNode);

  const rightNode = audioCtx.createStereoPanner();
  rightNode.pan.setValueAtTime(1, audioCtx.currentTime);
  rightNode.connect(gainNode);

  const leftOsc = audioCtx.createOscillator();
  leftOsc.type = 'sine';
  leftOsc.connect(leftNode);

  const rightOsc = audioCtx.createOscillator();
  rightOsc.type = 'sine';
  rightOsc.connect(rightNode);

  // Parse steps (ms, Hz, Hz)
  const steps = raw
    .map(line => line.trim())
    .filter(Boolean)
    .map(line => {
      const [time, leftFreq, rightFreq] = line.split(',').map(Number);
      return { time, leftFreq, rightFreq };
    })
    .sort((a,b) => a.time - b.time);

  // keep the URL share feature
  location.hash = uint32ArrayToBase64(new Uint32Array(
    raw.filter(x => x.trim() !== '')
       .map(line => line.split(',').map(x => parseInt(x, 10)))
       .reduce((out, cur) => out.concat(cur), [])
  ));

  const loopDurSec = steps[steps.length - 1].time / 1000;
  const startTime = audioCtx.currentTime + 0.05; // small buffer to start clean
  let nextLoopIndex = 0;

  function scheduleLoop(loopIndex) {
    const base = startTime + loopIndex * loopDurSec;

    // Anchor first point to avoid implicit ramps from previous automation
    leftOsc.frequency.setValueAtTime(steps[0].leftFreq,  base + steps[0].time / 1000);
    rightOsc.frequency.setValueAtTime(steps[0].rightFreq, base + steps[0].time / 1000);

    for (let i = 1; i < steps.length; i++) {
      const s = steps[i];
      leftOsc.frequency.linearRampToValueAtTime(s.leftFreq,  base + s.time / 1000);
      rightOsc.frequency.linearRampToValueAtTime(s.rightFreq, base + s.time / 1000);
    }
  }

  // Prime a couple of loops so weâ€™re always ahead on the audio timeline
  scheduleLoop(nextLoopIndex++);
  scheduleLoop(nextLoopIndex++);

  // Short, frequent scheduler keeps us ahead without drift
  const LOOKAHEAD_SEC = 0.5;
  const scheduler = setInterval(() => {
    while (startTime + nextLoopIndex * loopDurSec < audioCtx.currentTime + LOOKAHEAD_SEC) {
      scheduleLoop(nextLoopIndex++);
    }
  }, 100);

  // UI + teardown
  event.target.textContent = 'Stop';
  const origHandler = event.target.onclick;

  event.target.onclick = function () {
    // fade out, cancel future automation, then stop
    gainNode.gain.linearRampToValueAtTime(0.00000001, audioCtx.currentTime + 0.1);
    leftOsc.frequency.cancelScheduledValues(audioCtx.currentTime);
    rightOsc.frequency.cancelScheduledValues(audioCtx.currentTime);

    setTimeout(() => { leftOsc.stop(); rightOsc.stop(); }, 200);
    clearInterval(scheduler);

    event.target.textContent = 'Play';
    event.target.onclick = origHandler;
  };

  leftOsc.start(startTime);
  rightOsc.start(startTime);
}

function uint32ArrayToBase64(u32) {
  return uint8ArrayToBase64(new Uint8Array(u32.buffer));
}

function base64ToUint32Array(b64) {
  const in8 = base64ToUint8Array(b64);
  const buffer = new ArrayBuffer(in8.length);
  const out8 = new Uint8Array(buffer);
  for(let i = 0; i<in8.length; i++) out8[i] = in8[i];
  return new Uint32Array(buffer);
}

function uint8ArrayToBase64(u8) {
  return btoa(String.fromCharCode.apply(null, u8));
}

function base64ToUint8Array(str) {
  return atob(str).split('').map(function (c) { return c.charCodeAt(0); });
}

function readHash() {
  if(location.hash) {
    const sequence = base64ToUint32Array(location.hash.slice(1));
    let out = '';
    for(let i = 0; i<sequence.length; i+=3) out += sequence.slice(i,i+3).join(',') + '\n';
    document.querySelector('textarea').value = out;
  }
}

window.onhashchange = readHash;
readHash();

</script>
